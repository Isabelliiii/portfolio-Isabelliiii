---
title: "Predictive Policing - Technical Implementation"
subtitle: "MUSA 5080 - Fall 2025"
author: "Isabelle Li"
date: today
format:
  html:
    code-fold: show
    code-tools: true
    toc: true
    toc-depth: 3
    toc-location: left
    theme: cosmo
    embed-resources: true
editor: visual
execute:
  warning: false
  message: false
---

```{r setup}
#| echo: false
#| message: false
#| warning: false

# Load required packages
library(tidyverse)     
library(sf)            
library(here)           
library(viridis)        
library(terra)       
library(spdep)          
library(FNN)          
library(MASS)           
library(patchwork)      
library(knitr)          
library(kableExtra)     
library(classInt)     
library(here)

# Spatstat split into sub-packages
library(spatstat.geom)    
library(spatstat.explore) 


# Set options
options(scipen = 999)  
set.seed(5080)         

# Create consistent theme for visualizations
theme_crime <- function(base_size = 11) {
  theme_minimal(base_size = base_size) +
    theme(
      plot.title = element_text(face = "bold", size = base_size + 1),
      plot.subtitle = element_text(color = "gray30", size = base_size - 1),
      legend.position = "right",
      panel.grid.minor = element_blank(),
      axis.text = element_blank(),
      axis.title = element_blank()
    )
}

# Set as default
theme_set(theme_crime())

```

# Part 1: Load and Explore Data

```{r load-boundaries}
#| echo: false
#| message: false
#| warning: false

# Load police districts
policeDistricts <- st_read(
  "https://data.cityofchicago.org/api/geospatial/24zt-jpfn?method=export&format=GeoJSON",
  quiet = TRUE
) %>%
  st_transform('ESRI:102271') %>%
  dplyr::select(District = dist_num)

# Load police beats
policeBeats <- st_read(
  "https://data.cityofchicago.org/api/geospatial/n9it-hstw?method=export&format=GeoJSON",
  quiet = TRUE
) %>%
  st_transform('ESRI:102271') %>%
  dplyr::select(Beat = beat_num)

# Load Chicago boundary
chicagoBoundary <- st_read(
  "https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/DATA/Chapter5/chicagoBoundary.geojson",
  quiet = TRUE
) %>%
  st_transform('ESRI:102271')

```

```{r load-burglaries}
#| echo: false
#| message: false
#| warning: false

# Load from provided data file (downloaded from Chicago open data portal)
burglaries <- st_read(
  here("assignments", "assignment4", "data", "burglaries.shp"), quiet = TRUE
) %>% 
  st_transform('ESRI:102271')

```

There are **7,482 burglary incidents** in the dataset.\
These records come from the **Chicago Crimes 2017** data, representing all **reported burglary (forcible entry)** cases during that calendar year.

Datasets are projected into Illinois State Plane East (EPSG:102271) for accurate distance and area calculations.

## 1.2: Visualize Point Data

```{r visualize-points}
#| fig-width: 10
#| fig-height: 5

# Simple point map
p1 <- ggplot() + 
  geom_sf(data = chicagoBoundary, fill = "gray95", color = "gray60") +
  geom_sf(data = burglaries, color = "#d62828", size = 0.1, alpha = 0.4) +
  labs(
    title = "Burglary Locations",
    subtitle = paste0("Chicago 2017, n = ", nrow(burglaries))
  )

# Density surface using modern syntax
p2 <- ggplot() + 
  geom_sf(data = chicagoBoundary, fill = "gray95", color = "gray60") +
  geom_density_2d_filled(
    data = data.frame(st_coordinates(burglaries)),
    aes(X, Y),
    alpha = 0.7,
    bins = 8
  ) +
  scale_fill_viridis_d(
    option = "plasma",
    direction = -1,
    guide = "none"  # Modern ggplot2 syntax (not guide = FALSE)
  ) +
  labs(
    title = "Density Surface",
    subtitle = "Kernel density estimation"
  )

# Combine plots using patchwork (modern approach)
p1 + p2 + 
  plot_annotation(
    title = "Spatial Distribution of Burglaries in Chicago",
    tag_levels = 'A'
  )
```

The burglary incidents are **not evenly distributed** across Chicago. Instead, they exhibit a clear clustered pattern, with several well-defined hot spots.

The **highest concentrations** appear in:

-   the **West Side** (especially near Humboldt Park and Garfield Park),

-   parts of the **South Side**, and

-   portions of the **Near North / Near West** areas.

In contrast, the Northwest and Southwest outer neighborhoods show very few incidents, indicating substantially lower burglary activity.

# Part 2: Create Fishnet Grid

## 2.1: Understanding the Fishnet

A **fishnet grid** converts irregular point data into a regular grid of cells where we can:

-   Aggregate counts
-   Calculate spatial features
-   Apply regression models

```{r create-fishnet}
# Create 500m x 500m grid
fishnet <- st_make_grid(
  chicagoBoundary,
  cellsize = 500,  # 500 meters per cell
  square = TRUE
) %>%
  st_sf() %>%
  mutate(uniqueID = row_number())

# Keep only cells that intersect Chicago
fishnet <- fishnet[chicagoBoundary, ]

```

We use a regular fishnet grid because it provides **equal-sized spatial units**, which makes burglary counts directly comparable across the entire study area. Neighborhoods or census tracts vary widely in size and shape, and those differences can distort the spatial patterns we observe or bias the regression results. A uniform grid avoids those issues and creates a consistent framework for aggregating incidents, calculating spatial features, and fitting predictive models.

## 2.2: Aggregate Burglaries to Grid

```{r Burglaries Aggregate}

burglaries_fishnet <- st_join(burglaries, fishnet, join = st_within) %>%
  st_drop_geometry() %>%
  group_by(uniqueID) %>%
  summarize(countBurglaries = n())

# Join back to fishnet (cells with 0 burglaries will be NA)
fishnet <- fishnet %>%
  left_join(burglaries_fishnet, by = "uniqueID") %>%
  mutate(countBurglaries = replace_na(countBurglaries, 0))

fishnet %>%
  st_drop_geometry() %>%
  summarize(
    Min = min(countBurglaries),
    Q1 = quantile(countBurglaries, 0.25),
    Median = median(countBurglaries),
    Mean = mean(countBurglaries),
    Q3 = quantile(countBurglaries, 0.75),
    Max = max(countBurglaries),
    Percent_zero = mean(countBurglaries == 0) * 100
  ) %>%
  mutate(across(everything(), ~round(., 2))) %>%
  kable(
    caption = "Summary of Burglary Counts per 500m Grid Cell"
  ) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))


```

```{r visualize-fishnet}
#| fig-width: 8
#| fig-height: 6

# Visualize aggregated counts
ggplot() +
  geom_sf(data = fishnet, aes(fill = countBurglaries), color = NA) +
  geom_sf(data = chicagoBoundary, fill = NA, color = "white", linewidth = 1) +
  scale_fill_viridis_c(
    name = "Burglaries",
    option = "plasma",
    trans = "sqrt",  # Square root for better visualization of skewed data
    breaks = c(0, 1, 5, 10, 20, 40)
  ) +
  labs(
    title = "Burglary Counts by Grid Cell",
    subtitle = "500m x 500m cells, Chicago 2017"
  ) +
  theme_crime()
```

The distribution of burglary counts across grid cells is **highly skewed**. Most cells have **zero or very few incidents**, while a smaller number of cells contain moderate or high counts. This creates a classic “long-tail” distribution: many zeros, many low values, and a few high-value hot spots.

There are so many zero-burglary cells because a large portion of Chicago consists of areas where burglaries are rare—low-density residential zones, industrial corridors, parks, and other land uses that generate fewer targets or fewer opportunities for burglary. Burglary risk is not spatially uniform, so it is expected that many cells simply have no incidents during the study year.

# Part 3: Create a Kernel Density Baseline

```{r kde-baseline}
#| message: false
#| warning: false
#| echo: false

# Convert burglaries to ppp (point pattern) format for spatstat
burglaries_ppp <- as.ppp(
  st_coordinates(burglaries),
  W = as.owin(st_bbox(chicagoBoundary))
)

# Calculate KDE with 1km bandwidth
kde_burglaries <- density.ppp(
  burglaries_ppp,
  sigma = 1000,  # 1km bandwidth
  edge = TRUE    # Edge correction
)

# Convert to terra raster (modern approach, not raster::raster)
kde_raster <- rast(kde_burglaries)

# Extract KDE values to fishnet cells
fishnet <- fishnet %>%
  mutate(
    kde_value = terra::extract(
      kde_raster,
      vect(fishnet),
      fun = mean,
      na.rm = TRUE
    )[, 2]  # Extract just the values column
  )
```

```{r visualize-kde}
#| fig-width: 8
#| fig-height: 6

ggplot() +
  geom_sf(data = fishnet, aes(fill = kde_value), color = NA) +
  geom_sf(data = chicagoBoundary, fill = NA, color = "white", linewidth = 1) +
  scale_fill_viridis_c(
    name = "KDE Value",
    option = "plasma"
  ) +
  labs(
    title = "Kernel Density Estimation Baseline",
    subtitle = "Simple spatial smoothing of burglary locations"
  ) +
  theme_crime()
```

The KDE map produces a much smoother representation of burglary intensity compared to the raw count map. While the grid-based count map shows sharp cell-to-cell variation that high counts next to zero counts, the KDE surface spreads each point’s influence over space, revealing the **underlying structure** of burglary hot spots.

# Part 4: Create Spatial Predictor Variables

```{r load-abandoned-cars}
#| echo: false
#| message: false
#| warning: false

Graffiti_removal <- read_csv(  here("assignments", "assignment4", "data", "Graffiti_Removal.csv"))%>%
  filter(!is.na(Latitude), !is.na(Longitude)) %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326) %>%
  st_transform('ESRI:102271')

```

## 4.1: Count of Abandoned Cars per Cell

```{r count-Graffiti_removal}
Removal_fishnet <- st_join(fishnet, Graffiti_removal, join = st_contains) %>%
  st_drop_geometry() %>%
  count(uniqueID, name = "Graffiti_removal")

fishnet$Graffiti_removal <- 0L

idx <- match(Removal_fishnet$uniqueID, fishnet$uniqueID)
fishnet$Graffiti_removal[idx] <- Removal_fishnet$Graffiti_removal

fishnet %>%
  st_drop_geometry() %>%
  summarize(
    Min = min(Graffiti_removal),
    Q1 = quantile(Graffiti_removal, 0.25),
    Median = median(Graffiti_removal),
    Mean = mean(Graffiti_removal),
    Q3 = quantile(Graffiti_removal, 0.75),
    Max = max(Graffiti_removal)
  ) %>%
  mutate(across(everything(), ~round(., 2))) %>%
  kable(
    caption = "Summary of Graffiti Removal 311 Calls per 500m Grid Cell"
  ) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

```{r visualize-abandoned-cars}
#| fig-width: 10
#| fig-height: 4

p1 <- ggplot() +
  geom_sf(data = fishnet, aes(fill = Graffiti_removal), color = NA) +
  scale_fill_viridis_c(name = "Count", option = "magma") +
  labs(title = "Graffiti Removal 311 Calls") +
  theme_crime()

p2 <- ggplot() +
  geom_sf(data = fishnet, aes(fill = countBurglaries), color = NA) +
  scale_fill_viridis_c(name = "Count", option = "plasma") +
  labs(title = "Burglaries") +
  theme_crime()

p1 + p2 +
  plot_annotation(title = "Are Graffiti Removal and burglaries correlated?")
```

Visually, there does not appear to be a strong one-to-one spatial relationship between Graffiti Removal 311 calls and burglaries. Graffiti reports are highly concentrated in a few dense pockets especially in the Northwest, West, and parts of the Southwest, reflecting areas where property damage or visible disorder is more common. In contrast, burglaries show a broader and more diffuse spatial pattern with hotspots distributed across the West Side, South Side, and the North-Central corridor.

Although there is **some overlap** in general high-activity regions (such as parts of the West Side), the intensity patterns differ in both magnitude and spatial footprint. This suggests that graffiti is related to neighborhood disorder but **is not a direct proxy for burglary risk**. Graffiti reflects public-facing vandalism, while burglary involves private property intrusion, which is driven by different opportunity structures, land uses, and routine activities.

## 4.2: Nearest Neighbor Features

```{r nn-feature}
#| message: false
#| warning: false


# Calculate mean distance to 3 nearest Graffiti Removal
Graffiti_clean <- Graffiti_removal %>%
  filter(!st_is_empty(geometry))

# Get coordinates
fishnet_coords <- st_coordinates(st_centroid(fishnet))
removal_coords <- st_coordinates(Graffiti_clean)

# Calculate k nearest neighbors and distances
nn_result <- get.knnx(removal_coords, fishnet_coords, k = 3)

# Add to fishnet
fishnet <- fishnet %>%
  mutate(
    Graffiti_clean.nn = rowMeans(nn_result$nn.dist)
  )

fishnet %>%
  st_drop_geometry() %>%
  summarize(
    Min = min(Graffiti_clean.nn),
    Q1 = quantile(Graffiti_clean.nn, 0.25),
    Median = median(Graffiti_clean.nn),
    Mean = mean(Graffiti_clean.nn),
    Q3 = quantile(Graffiti_clean.nn, 0.75),
    Max = max(Graffiti_clean.nn)
  ) %>%
  mutate(across(everything(), ~round(., 2))) %>%
  kable(
    caption = "Summary of Mean Distance to 3 Nearest Graffiti Removal Calls (meters)"
  ) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))

```

The distance-to-graffiti feature shows substantial variation, with a median of \~60 m but a long tail up to 1.4 km. This indicates that some neighborhoods are very close to multiple graffiti complaints, while others are far removed. This spatial heterogeneity helps capture environmental disorder that may relate to burglary risk.

## 4.3: Distance to Hot Spots

```{r local-morans-abandoned}
#| echo: false
#| message: false
#| warning: false

# Function to calculate Local Moran's I
calculate_local_morans <- function(data, variable, k = 5) {
  
  # Create spatial weights
  coords <- st_coordinates(st_centroid(data))
  neighbors <- knn2nb(knearneigh(coords, k = k))
  weights <- nb2listw(neighbors, style = "W", zero.policy = TRUE)
  
  # Calculate Local Moran's I
  local_moran <- localmoran(data[[variable]], weights)
  
  # Classify clusters
  mean_val <- mean(data[[variable]], na.rm = TRUE)
  
  data %>%
    mutate(
      local_i = local_moran[, 1],
      p_value = local_moran[, 5],
      is_significant = p_value < 0.05,
      
      moran_class = case_when(
        !is_significant ~ "Not Significant",
        local_i > 0 & .data[[variable]] > mean_val ~ "High-High",
        local_i > 0 & .data[[variable]] <= mean_val ~ "Low-Low",
        local_i < 0 & .data[[variable]] > mean_val ~ "High-Low",
        local_i < 0 & .data[[variable]] <= mean_val ~ "Low-High",
        TRUE ~ "Not Significant"
      )
    )
}

# Apply to Graffiti removal
fishnet <- calculate_local_morans(fishnet, "Graffiti_removal", k = 5)
```

```{r visualize-morans}
#| fig-width: 8
#| fig-height: 6

# Visualize hot spots
ggplot() +
  geom_sf(
    data = fishnet, 
    aes(fill = moran_class), 
    color = NA
  ) +
  scale_fill_manual(
    values = c(
      "High-High" = "#d7191c",
      "High-Low" = "#fdae61",
      "Low-High" = "#abd9e9",
      "Low-Low" = "#2c7bb6",
      "Not Significant" = "gray90"
    ),
    name = "Cluster Type"
  ) +
  labs(
    title = "Local Moran's I: Graffiti Removal Clusters",
    subtitle = "High-High = Hot spots of disorder"
  ) +
  theme_crime()
```

```{r distance-to-hotspots}
#| echo: false
#| message: false
#| warning: false

# Identify hotspot cells
hotspots <- fishnet %>%
  filter(moran_class == "High-High") %>%
  st_centroid()

# Calculate distance from each cell to nearest hotspot
if (nrow(hotspots) > 0) {
  fishnet <- fishnet %>%
    mutate(
      dist_to_hotspot = as.numeric(
        st_distance(st_centroid(fishnet), hotspots %>% st_union())
      )
    )
} else {
  fishnet <- fishnet %>%
    mutate(dist_to_hotspot = 0)
}

```

Distance to a cluster of Graffiti Removal calls is more informative than distance to a single graffiti incident because it captures the broader neighborhood context of disorder. A single report might be noisy or idiosyncratic, but a High–High cluster from Local Moran’s I represents an area where both the cell and its neighbors have consistently high graffiti counts. Being close to such a cluster suggests that a grid cell lies within or near a larger zone of visible deterioration or neglect.

------------------------------------------------------------------------

```{r join-districts}
#| echo: false
#| message: false
#| warning: false

# Join district information to fishnet
fishnet <- st_join(
  fishnet,
  policeDistricts,
  join = st_within,
  left = TRUE
) %>%
  filter(!is.na(District))  # Remove cells outside districts

```

# Part 5: Model Fitting

## 5.1: Poisson Regression

```{r prepare-data}
#| echo: false
#| message: false
#| warning: false
# Create clean modeling dataset
fishnet_model <- fishnet %>%
  st_drop_geometry() %>%
  dplyr::select(
    uniqueID,
    District,
    countBurglaries,
    Graffiti_removal,
    Graffiti_clean.nn,
    dist_to_hotspot
  ) %>%
  na.omit()  # Remove any remaining NAs

```

```{r fit-poisson}
# Fit Poisson regression
library(broom)

model_poisson <- glm(
  countBurglaries ~ Graffiti_removal + Graffiti_clean.nn + 
    dist_to_hotspot,
  data = fishnet_model,
  family = "poisson"
)

poisson_tbl <- tidy(model_poisson) %>% 
  mutate(
    estimate = round(estimate, 4),
    std.error = round(std.error, 4),
    statistic = round(statistic, 2),
    p.value = round(p.value, 4)
  )

kable(
  poisson_tbl,
  caption = "Poisson Regression Results"
) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))

```

**All three predictors are statistically significant (p \< 0.001).**

1.   **Graffiti_removal** has a *positive* association with burglary counts.

    More graffiti complaints → slightly more burglaries.

2.  **Graffiti_clean.nn** has a *strong negative* association.

    Cells closer to graffiti activity → much higher burglary risk.

    This is the strongest predictor in the model.

3.  **dist_to_hotspot** has a very weak but statistically significant *positive* association.

    Being farther from graffiti hotspots slightly increases predicted burglaries.

    Effect size is tiny and may not be meaningful.

```{r check-overdispersion}
#| echo: false
#| message: false
#| warning: false
# Calculate dispersion parameter
dispersion <- sum(residuals(model_poisson, type = "pearson")^2) / 
              model_poisson$df.residual

```

## 6.2: Negative Binomial Regression

If overdispersed, use **Negative Binomial regression** (more flexible).

```{r fit-negbin}
# Fit Negative Binomial model
model_nb <- glm.nb(
  countBurglaries ~ Graffiti_removal + Graffiti_clean.nn + 
    dist_to_hotspot,
  data = fishnet_model
)

nb_tbl <- tidy(model_nb) %>%
  mutate(
    estimate = round(estimate, 4),
    std.error = round(std.error, 4),
    statistic = round(statistic, 2),
    p.value = round(p.value, 4)
  )

kable(
  nb_tbl,
  caption = "Negative Binomial Regression Results"
) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

Its AIC (7654) is substantially lower than the Poisson model's AIC (9456), indicating that the NB model provides a better balance between model complexity and goodness of fit.

The improvement confirms that our burglary count data are overdispersed (variance \> mean), which violates a key Poisson assumption. As a result, the Poisson model inflated the significance of several predictors, while the NB model provides more reliable coefficient estimates.

# Part 7: Spatial Cross-Validation

```{r spatial-cv}
#| echo: false
#| message: false
#| warning: false
#| results: hide

# Get unique districts
districts <- unique(fishnet_model$District)
cv_results <- tibble()

cat("Running LOGO Cross-Validation...\n")

for (i in seq_along(districts)) {
  
  test_district <- districts[i]
  
  # Split data
  train_data <- fishnet_model %>% filter(District != test_district)
  test_data <- fishnet_model %>% filter(District == test_district)
  
  # Fit model on training data
  model_cv <- glm.nb(
    countBurglaries ~ Graffiti_removal + Graffiti_clean.nn + 
      dist_to_hotspot,
    data = train_data
  )
  
  # Predict on test data
  test_data <- test_data %>%
    mutate(
      prediction = predict(model_cv, test_data, type = "response")
    )
  
  # Calculate metrics
  mae <- mean(abs(test_data$countBurglaries - test_data$prediction))
  rmse <- sqrt(mean((test_data$countBurglaries - test_data$prediction)^2))
  
  # Store results
  cv_results <- bind_rows(
    cv_results,
    tibble(
      fold = i,
      test_district = test_district,
      n_test = nrow(test_data),
      mae = mae,
      rmse = rmse
    )
  )
  
  cat("  Fold", i, "/", length(districts), "- District", test_district, 
      "- MAE:", round(mae, 2), "\n")
}

```

```{r cv-results-table}
# Show results
cv_results %>%
  arrange(desc(mae)) %>%
  kable(
    digits = 2,
    caption = "LOGO CV Results by District"
  ) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

Spatial CV is more appropriate than random CV because crime data is highly spatially autocorrelated. Random CV would mix neighboring cells into both training and testing sets, causing spatial leakage and artificially inflating model performance. LOGO CV avoids this by holding out entire police districts, which tests the model’s ability to generalize to new spatial areas.

From the results, District 3 was the hardest to predict (MAE = 6.31), followed by District 6, suggesting that these areas have unique burglary patterns not well explained by graffiti-based predictors. In contrast, District 19 was one of the easiest districts to predict (MAE ≈ 1.9), indicating burglary patterns there are more stable and similar to the training data.

# Part 8: Model Predictions and Comparison

```{r final-predictions}
#| echo: false
#| message: false
#| warning: false
# Fit final model on all data
final_model <- glm.nb(
  countBurglaries ~ Graffiti_removal + Graffiti_clean.nn + 
    dist_to_hotspot,
  data = fishnet_model
)

# Add predictions back to fishnet
fishnet <- fishnet %>%
  mutate(
    prediction_nb = predict(final_model, fishnet_model, type = "response")[match(uniqueID, fishnet_model$uniqueID)]
  )

# Also add KDE predictions (normalize to same scale as counts)
kde_sum <- sum(fishnet$kde_value, na.rm = TRUE)
count_sum <- sum(fishnet$countBurglaries, na.rm = TRUE)
fishnet <- fishnet %>%
  mutate(
    prediction_kde = (kde_value / kde_sum) * count_sum
  )
```

## 8.1: Compare Model vs. KDE Baseline

```{r compare-models}
#| fig-width: 12
#| fig-height: 4

# Create three maps
p1 <- ggplot() +
  geom_sf(data = fishnet, aes(fill = countBurglaries), color = NA) +
  scale_fill_viridis_c(name = "Count", option = "plasma", limits = c(0, 15)) +
  labs(title = "Actual Burglaries") +
  theme_crime()

p2 <- ggplot() +
  geom_sf(data = fishnet, aes(fill = prediction_nb), color = NA) +
  scale_fill_viridis_c(name = "Predicted", option = "plasma", limits = c(0, 15)) +
  labs(title = "Model Predictions (Neg. Binomial)") +
  theme_crime()

p3 <- ggplot() +
  geom_sf(data = fishnet, aes(fill = prediction_kde), color = NA) +
  scale_fill_viridis_c(name = "Predicted", option = "plasma", limits = c(0, 15)) +
  labs(title = "KDE Baseline Predictions") +
  theme_crime()

p1 + p2 + p3 +
  plot_annotation(
    title = "Actual vs. Predicted Burglaries",
    subtitle = "Does our complex model outperform simple KDE?"
  )
```

```{r model-comparison-metrics}
# Calculate performance metrics
comparison <- fishnet %>%
  st_drop_geometry() %>%
  filter(!is.na(prediction_nb), !is.na(prediction_kde)) %>%
  summarize(
    model_mae = mean(abs(countBurglaries - prediction_nb)),
    model_rmse = sqrt(mean((countBurglaries - prediction_nb)^2)),
    kde_mae = mean(abs(countBurglaries - prediction_kde)),
    kde_rmse = sqrt(mean((countBurglaries - prediction_kde)^2))
  )

comparison %>%
  pivot_longer(everything(), names_to = "metric", values_to = "value") %>%
  separate(metric, into = c("approach", "metric"), sep = "_") %>%
  pivot_wider(names_from = metric, values_from = value) %>%
  kable(
    digits = 2,
    caption = "Model Performance Comparison"
  ) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

### **The KDE baseline performs better than the complex model**

The KDE has **lower MAE and RMSE**, which means:

-   Smaller average prediction error

-   More stable predictions

-   Better overall fit to the spatial pattern of burglaries

This is a common result in spatial prediction tasks: KDE is extremely strong because crime tends to cluster, and KDE captures clustering very well without requiring any assumptions or regression structure.

## 8.2: Where Does the Model Work Well?

```{r prediction-errors}
#| fig-width: 10
#| fig-height: 5

# Calculate errors
fishnet <- fishnet %>%
  mutate(
    error_nb = countBurglaries - prediction_nb,
    error_kde = countBurglaries - prediction_kde,
    abs_error_nb = abs(error_nb),
    abs_error_kde = abs(error_kde)
  )

# Map errors
p1 <- ggplot() +
  geom_sf(data = fishnet, aes(fill = error_nb), color = NA) +
  scale_fill_gradient2(
    name = "Error",
    low = "#2166ac", mid = "white", high = "#b2182b",
    midpoint = 0,
    limits = c(-10, 10)
  ) +
  labs(title = "Model Errors (Actual - Predicted)") +
  theme_crime()

p2 <- ggplot() +
  geom_sf(data = fishnet, aes(fill = abs_error_nb), color = NA) +
  scale_fill_viridis_c(name = "Abs. Error", option = "magma") +
  labs(title = "Absolute Model Errors") +
  theme_crime()

p1 + p2
```

The error maps show that the Negative Binomial model systematically underpredicts burglaries in major hotspot areas especially in the South and West Sides, while slightly overpredicting in low-crime neighborhoods. This pattern suggests that the model cannot fully capture sharp, localized spikes in burglary activity, likely because graffiti-related predictors only partially reflect the underlying opportunity structures of crime. As a result, absolute errors are largest in high-crime districts and much smaller in low-crime ones, indicating that the model performs unevenly across space and is least accurate exactly where prediction is most important.

# Part 9: Summary Statistics and Tables

## 9.1: Model Summary Table

```{r model-summary-table}
# Create nice summary table
model_summary <- broom::tidy(final_model, exponentiate = TRUE) %>%
  mutate(
    across(where(is.numeric), ~round(., 3))
  )

model_summary %>%
  kable(
    caption = "Final Negative Binomial Model Coefficients (Exponentiated)",
    col.names = c("Variable", "Rate Ratio", "Std. Error", "Z", "P-Value")
  ) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  footnote(
    general = "Rate ratios > 1 indicate positive association with burglary counts."
  )
```

## 9.2: Key Findings Summary

**Technical Performance:**

-   Cross-validation MAE: 2.56
-   Model vs. KDE: The **KDE baseline outperformed the regression model** (KDE MAE = 2.06 vs. Model MAE = 2.56), indicating that simple spatial smoothing captures burglary risk better than our feature-based mode.
-   Most predictive variable: **Graffiti_clean.nn** (distance to nearest graffiti-removal activity) had the strongest and most statistically significant effect (rate ratio ≈ 0.992).

**Spatial Patterns:**

-   Burglaries are **Strongly clustered**, not evenly distributed.
-   Hot spots are located in The **West Side**, parts of the **Near Northwest**, and the **South Side near major commercial corridors**.
-   Model errors show systematic spatial patterns.

**Model Limitations:**

-   Overdispersion
-   Spatial autocorrelation in residuals: Likely **present** (errors cluster spatially), suggesting missing spatial processes or unobserved neighborhood characteristics.
-   Cells with zero counts: A large share of grid cells have zero burglaries (typically **\>50%**), making the count distribution highly zero-inflated.
